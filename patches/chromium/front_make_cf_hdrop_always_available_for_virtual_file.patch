From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jeremy Spiegel <jeremy.spiegel@frontapp.com>
Date: Wed, 2 Oct 2019 11:08:13 -0700
Subject: Front: Make CF_HDROP always available for virtual file


diff --git a/content/browser/download/drag_download_file.cc b/content/browser/download/drag_download_file.cc
index c6deec13817ce75d270eaf76514129ca9fbe204c..d01c15bc125ad0af2fa09e90a763e4b41c1c396b 100644
--- a/content/browser/download/drag_download_file.cc
+++ b/content/browser/download/drag_download_file.cc
@@ -28,6 +28,7 @@ namespace content {
 namespace {

 typedef base::Callback<void(bool)> OnCompleted;
+typedef base::Callback<void(int)> OnProgress;

 }  // namespace

@@ -39,8 +40,10 @@ class DragDownloadFile::DragDownloadFileUI
                      const Referrer& referrer,
                      const std::string& referrer_encoding,
                      WebContents* web_contents,
-                     const OnCompleted& on_completed)
+                     const OnCompleted& on_completed,
+                     const OnProgress& on_progress)
       : on_completed_(on_completed),
+        on_progress_(on_progress),
         url_(url),
         referrer_(referrer),
         referrer_encoding_(referrer_encoding),
@@ -147,8 +150,12 @@ class DragDownloadFile::DragDownloadFileUI
       }
       download_item_->RemoveObserver(this);
       download_item_ = nullptr;
+    } else {
+      base::PostTask(
+          FROM_HERE, {BrowserThread::UI},
+          base::BindOnce(on_progress_,
+                         download_item_->PercentComplete()));
     }
-    // Ignore other states.
   }

   void OnDownloadDestroyed(download::DownloadItem* item) override {
@@ -166,6 +173,7 @@ class DragDownloadFile::DragDownloadFileUI
   }

   OnCompleted on_completed_;
+  OnProgress on_progress_;
   GURL url_;
   Referrer referrer_;
   std::string referrer_encoding_;
@@ -192,7 +200,9 @@ DragDownloadFile::DragDownloadFile(const base::FilePath& file_path,
   drag_ui_ =
       new DragDownloadFileUI(url, referrer, referrer_encoding, web_contents,
                              base::Bind(&DragDownloadFile::DownloadCompleted,
-                                        weak_ptr_factory_.GetWeakPtr()));
+                                        weak_ptr_factory_.GetWeakPtr()),
+                             base::Bind(&DragDownloadFile::DownloadProgressed,
+                                        weak_ptr_factory_.GetWeakPtr()));
   DCHECK(!file_path_.empty());
 }

@@ -261,4 +271,10 @@ void DragDownloadFile::DownloadCompleted(bool is_successful) {
     file_observer->OnDownloadAborted();
 }

+void DragDownloadFile::DownloadProgressed(int percent_complete) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  observer_->OnDownloadProgressed(percent_complete);
+}
+
 }  // namespace content
diff --git a/content/browser/download/drag_download_file.h b/content/browser/download/drag_download_file.h
index 25dc7db9b96090bb5c937793fc8b827fe653564b..7b37c12fa4c959d364a1132f2eb2d45ad0775f64 100644
--- a/content/browser/download/drag_download_file.h
+++ b/content/browser/download/drag_download_file.h
@@ -54,6 +54,7 @@ class CONTENT_EXPORT DragDownloadFile : public ui::DownloadFileProvider {
   enum State {INITIALIZED, STARTED, SUCCESS, FAILURE};

   void DownloadCompleted(bool is_successful);
+  void DownloadProgressed(int percent_complete);
   void CheckThread();

   base::FilePath file_path_;
diff --git a/content/browser/download/drag_download_util.cc b/content/browser/download/drag_download_util.cc
index 4d8e800ae87307ee7e90c0bff006e8549ab62290..5021611d1a6f02c8361be79fe36595d54c1415d6 100644
--- a/content/browser/download/drag_download_util.cc
+++ b/content/browser/download/drag_download_util.cc
@@ -101,6 +101,9 @@ void PromiseFileFinalizer::OnDownloadCompleted(
                  base::BindOnce(&PromiseFileFinalizer::Cleanup, this));
 }

+void PromiseFileFinalizer::OnDownloadProgressed(int percent_complete) {
+}
+
 void PromiseFileFinalizer::OnDownloadAborted() {
   base::PostTask(FROM_HERE, {BrowserThread::UI},
                  base::BindOnce(&PromiseFileFinalizer::Cleanup, this));
diff --git a/content/browser/download/drag_download_util.h b/content/browser/download/drag_download_util.h
index a019fc2ce15d09dffaaa5783a07500fcd52b5509..f57232e2e8333132332ea6c83451be0503b50acc 100644
--- a/content/browser/download/drag_download_util.h
+++ b/content/browser/download/drag_download_util.h
@@ -47,6 +47,7 @@ class PromiseFileFinalizer : public ui::DownloadFileObserver {

   // DownloadFileObserver methods.
   void OnDownloadCompleted(const base::FilePath& file_path) override;
+  void OnDownloadProgressed(int percent_complete) override;
   void OnDownloadAborted() override;

  protected:
diff --git a/content/browser/web_contents/web_contents_view_aura.cc b/content/browser/web_contents/web_contents_view_aura.cc
index 5368aafddd91cc75075700c8f93e3d7ea8f6435b..ea5da1960e83bdf82a8990166003ba5014b00b64 100644
--- a/content/browser/web_contents/web_contents_view_aura.cc
+++ b/content/browser/web_contents/web_contents_view_aura.cc
@@ -219,7 +219,7 @@ void PrepareDragForDownload(
       download_path, base::File(), download_url,
       Referrer(page_url, drop_data.referrer_policy), page_encoding,
       web_contents);
-  ui::OSExchangeData::DownloadFileInfo file_download(base::FilePath(),
+  ui::OSExchangeData::DownloadFileInfo file_download(download_path,
                                                      std::move(download_file));
   provider->SetDownloadFileInfo(&file_download);
 }
diff --git a/ui/base/dragdrop/download_file_interface.h b/ui/base/dragdrop/download_file_interface.h
index 72e41ce4a40921f469bcc76eaa2017a5a495b89a..cceb41c7144bbd96f1b3a52b7270226b4885d1ad 100644
--- a/ui/base/dragdrop/download_file_interface.h
+++ b/ui/base/dragdrop/download_file_interface.h
@@ -26,6 +26,7 @@ class UI_BASE_EXPORT DownloadFileObserver
     : public base::RefCountedThreadSafe<DownloadFileObserver> {
  public:
   virtual void OnDownloadCompleted(const base::FilePath& file_path) = 0;
+  virtual void OnDownloadProgressed(int percentComplete) = 0;
   virtual void OnDownloadAborted() = 0;

  protected:
diff --git a/ui/base/dragdrop/drag_source_win.cc b/ui/base/dragdrop/drag_source_win.cc
index a797a721a7737aacf206a3ce4c21c25628126313..e22e9908cb5e9f1885e75d336468448434239b43 100644
--- a/ui/base/dragdrop/drag_source_win.cc
+++ b/ui/base/dragdrop/drag_source_win.cc
@@ -38,6 +38,7 @@ HRESULT DragSourceWin::GiveFeedback(DWORD effect) {
 }

 void DragSourceWin::OnDragSourceDrop() {
+  LOG(INFO) << "DragSourceWin::OnDragSourceDrop";
   DCHECK(data_);
   ui::OSExchangeDataProviderWin::GetDataObjectImpl(*data_)
       ->set_in_drag_loop(false);
diff --git a/ui/base/dragdrop/os_exchange_data_provider_win.cc b/ui/base/dragdrop/os_exchange_data_provider_win.cc
index 4b7c0656c60b09f61ab201c2900d5b4d6844f4d2..e6774201a2c230030bbfd508bf81c68edc6baceb 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_win.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_win.cc
@@ -10,22 +10,27 @@
 #include <shlobj.h>
 #include <shobjidl.h>
 #include <stdint.h>
+#include <windowsx.h>
 #include <wrl/client.h>

 #include <algorithm>
 #include <iterator>

+#include "base/files/file.h"
 #include "base/callback.h"
 #include "base/containers/span.h"
 #include "base/files/file_path.h"
 #include "base/i18n/file_util_icu.h"
+#include "base/lazy_instance.h"
 #include "base/logging.h"
 #include "base/no_destructor.h"
 #include "base/pickle.h"
 #include "base/stl_util.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/win/current_module.h"
 #include "base/win/scoped_hdc.h"
 #include "base/win/scoped_hglobal.h"
+#include "base/win/wrapped_window_proc.h"
 #include "base/win/shlwapi.h"
 #include "net/base/filename_util.h"
 #include "skia/ext/skia_utils_win.h"
@@ -298,9 +303,12 @@ OSExchangeDataProviderWin::Clone() const {
 }

 void OSExchangeDataProviderWin::MarkOriginatedFromRenderer() {
+  // Needed for drops to VS Code to work
+#if 0
   STGMEDIUM* storage = GetStorageForString(std::string());
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
       GetRendererTaintFormatType().ToFormatEtc(), storage));
+#endif
 }

 bool OSExchangeDataProviderWin::DidOriginateFromRenderer() const {
@@ -320,6 +328,7 @@ void OSExchangeDataProviderWin::SetString(const base::string16& data) {

 void OSExchangeDataProviderWin::SetURL(const GURL& url,
                                        const base::string16& title) {
+  LOG(INFO) << "SetURL url: " << url.spec() << " title: " << title;
   // NOTE WELL:
   // Every time you change the order of the first two CLIPFORMATS that get
   // added here, you need to update the EnumerationViaCOM test case in
@@ -505,6 +514,8 @@ void OSExchangeDataProviderWin::SetPickledData(
 void OSExchangeDataProviderWin::SetFileContents(
     const base::FilePath& filename,
     const std::string& file_contents) {
+  LOG(INFO) << "SetFileContents filename: " << filename.value()
+            << ", file_contents: " << file_contents;
   // Add CFSTR_FILEDESCRIPTORW.
   STGMEDIUM* storage = GetStorageForFileDescriptor(filename);
   data_->contents_.push_back(std::make_unique<DataObjectImpl::StoredDataInfo>(
@@ -559,6 +570,7 @@ bool OSExchangeDataProviderWin::GetURLAndTitle(
 }

 bool OSExchangeDataProviderWin::GetFilename(base::FilePath* path) const {
+  LOG(INFO) << "GetFilename";
   std::vector<base::string16> filenames;
   bool success = ClipboardUtil::GetFilenames(source_object_.Get(), &filenames);
   if (success)
@@ -568,6 +580,11 @@ bool OSExchangeDataProviderWin::GetFilename(base::FilePath* path) const {

 bool OSExchangeDataProviderWin::GetFilenames(
     std::vector<FileInfo>* filenames) const {
+  LOG(INFO) << "GetFilenames";
+  if (HasCustomFormat(ClipboardFormatType::GetType("CF_FrontDragSource")) &&
+      !HasCustomFormat(ClipboardFormatType::GetType("CF_FrontInDragLoop")))
+    return false;
+
   std::vector<base::string16> filenames_local;
   bool success =
       ClipboardUtil::GetFilenames(source_object_.Get(), &filenames_local);
@@ -684,13 +701,18 @@ bool OSExchangeDataProviderWin::HasCustomFormat(

 void OSExchangeDataProviderWin::SetDownloadFileInfo(
     OSExchangeData::DownloadFileInfo* download) {
+  LOG(INFO) << "SetDownloadFileInfo download->filename: "
+            << download->filename.value();
+  data_->download_file_provider_ = download->downloader.get();
+  data_->download_file_provider_->Start(data_.get());
+  base::File(download->filename, base::File::FLAG_CREATE);
   // If the filename is not provided, set storage to NULL to indicate that
   // the delay rendering will be used.
   // TODO(dcheng): Is it actually possible for filename to be empty here? I
   // think we always synthesize one in WebContentsDragWin.
   STGMEDIUM* storage = NULL;
   if (!download->filename.empty())
-    GetStorageForFileNames({FileInfo(download->filename, base::FilePath())});
+    storage = GetStorageForFileNames({FileInfo(download->filename, base::FilePath())});

   // Add CF_HDROP.
   auto info = std::make_unique<DataObjectImpl::StoredDataInfo>(
@@ -699,7 +721,7 @@ void OSExchangeDataProviderWin::SetDownloadFileInfo(
   data_->contents_.push_back(std::move(info));

   // Adding a download file always enables async mode.
-  data_->SetAsyncMode(VARIANT_TRUE);
+  // data_->SetAsyncMode(VARIANT_TRUE);
 }

 void OSExchangeDataProviderWin::SetDragImage(
@@ -840,9 +862,97 @@ static void DuplicateMedium(CLIPFORMAT source_clipformat,
     destination->pUnkForRelease->AddRef();
 }

+std::wstring FormatFormatEtc(const FORMATETC* format_etc) {
+  std::wstring result = L"(";
+  WCHAR name[1024]{};
+  switch (format_etc->cfFormat) {
+    case CF_TEXT:
+      result += L"CF_TEXT";
+      break;
+    case CF_BITMAP:
+      result += L"CF_BITMAP";
+      break;
+    case CF_METAFILEPICT:
+      result += L"CF_METAFILEPICT";
+      break;
+    case CF_SYLK:
+      result += L"CF_SYLK";
+      break;
+    case CF_DIF:
+      result += L"CF_DIF";
+      break;
+    case CF_TIFF:
+      result += L"CF_TIFF";
+      break;
+    case CF_OEMTEXT:
+      result += L"CF_OEMTEXT";
+      break;
+    case CF_DIB:
+      result += L"CF_DIB";
+      break;
+    case CF_PALETTE:
+      result += L"CF_PALETTE";
+      break;
+    case CF_PENDATA:
+      result += L"CF_PENDATA";
+      break;
+    case CF_RIFF:
+      result += L"CF_RIFF";
+      break;
+    case CF_WAVE:
+      result += L"CF_WAVE";
+      break;
+    case CF_UNICODETEXT:
+      result += L"CF_UNICODETEXT";
+      break;
+    case CF_ENHMETAFILE:
+      result += L"CF_ENHMETAFILE";
+      break;
+    case CF_HDROP:
+      result += L"CF_HDROP";
+      break;
+    case CF_LOCALE:
+      result += L"CF_LOCALE";
+      break;
+    case CF_DIBV5:
+      result += L"CF_DIBV5";
+      break;
+    default: {
+      GetClipboardFormatName(format_etc->cfFormat, name, 1024);
+      result +=
+          (name[0] ? name : std::to_wstring(format_etc->cfFormat).c_str());
+    }
+  }
+
+  result += L" tymed: ";
+  if (format_etc->tymed & TYMED_HGLOBAL)
+    result += L"TYMED_HGLOBAL|";
+  if (format_etc->tymed & TYMED_FILE)
+    result += L"TYMED_FILE|";
+  if (format_etc->tymed & TYMED_ISTREAM)
+    result += L"TYMED_ISTREAM|";
+  if (format_etc->tymed & TYMED_ISTORAGE)
+    result += L"TYMED_ISTORAGE|";
+  if (format_etc->tymed & TYMED_GDI)
+    result += L"TYMED_GDI|";
+  if (format_etc->tymed & TYMED_MFPICT)
+    result += L"TYMED_MFPICT|";
+  if (format_etc->tymed & TYMED_ENHMF)
+    result += L"TYMED_ENHMF|";
+  result += L" lindex=";
+  result += std::to_wstring(format_etc->lindex).c_str();
+  result += L" dwAspect=";
+  result += std::to_wstring(format_etc->dwAspect).c_str();
+  result += L")";
+  return result;
+}
+
 DataObjectImpl::StoredDataInfo::StoredDataInfo(const FORMATETC& format_etc,
                                                STGMEDIUM* medium)
-    : format_etc(format_etc), medium(medium), owns_medium(true) {}
+    : format_etc(format_etc), medium(medium), owns_medium(true) {
+  LOG(INFO) << "StoredDataInfo::StoredDataInfo format_etc: "
+            << FormatFormatEtc(&format_etc) << ", medium: " << (medium ? 1 : 0);
+}

 DataObjectImpl::StoredDataInfo::~StoredDataInfo() {
   if (owns_medium) {
@@ -857,7 +967,13 @@ DataObjectImpl::DataObjectImpl()
     : is_aborting_(false),
       in_drag_loop_(false),
       in_async_mode_(false),
-      async_operation_started_(false) {}
+      async_operation_started_(false),
+      download_finished_(false),
+      download_progress_window_(NULL),
+      download_progress_control_(NULL),
+      download_progress_font_(NULL),
+      download_file_provider_(0),
+      download_progress_(0) {}

 DataObjectImpl::~DataObjectImpl() {
   StopDownloads();
@@ -873,6 +989,8 @@ void DataObjectImpl::StopDownloads() {
 }

 void DataObjectImpl::RemoveData(const FORMATETC& format) {
+  LOG(INFO) << "RemoveData in_drag_loop: " << in_drag_loop_
+            << " format_etc: " << FormatFormatEtc(&format);
   if (format.ptd)
     return;  // Don't attempt to compare target devices.

@@ -889,6 +1007,9 @@ void DataObjectImpl::RemoveData(const FORMATETC& format) {
 }

 void DataObjectImpl::OnDownloadCompleted(const base::FilePath& file_path) {
+  if (download_progress_window_)
+    PostMessage(download_progress_window_, WM_CLOSE, 0, 0);
+#if 0
   for (std::unique_ptr<StoredDataInfo>& content : contents_) {
     if (content->format_etc.cfFormat == CF_HDROP) {
       // Retrieve the downloader first so it won't get destroyed.
@@ -898,24 +1019,224 @@ void DataObjectImpl::OnDownloadCompleted(const base::FilePath& file_path) {
       // Replace stored data.
       STGMEDIUM* storage =
           GetStorageForFileNames({FileInfo(file_path, base::FilePath())});
-      content = std::make_unique<StoredDataInfo>(
-          ClipboardFormatType::GetCFHDropType().ToFormatEtc(), storage);
-      content->downloader = std::move(downloader);
       break;
     }
   }
+#endif
+}
+
+void DataObjectImpl::OnDownloadProgressed(int percent_complete) {
+  LOG(INFO) << "OnDownloadProgressed, percent_complete: " << percent_complete;
+  if (download_progress_control_)
+    SendMessage(download_progress_control_, PBM_SETPOS,
+                (WPARAM)percent_complete, 0);
+  download_progress_ = percent_complete;
+}
+
+void DataObjectImpl::OnDownloadAborted() {
+  if (download_progress_window_)
+    PostMessage(download_progress_window_, WM_CLOSE, 0, 0);
+}
+
+BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpcs) {
+  DataObjectImpl* data_object =
+      reinterpret_cast<DataObjectImpl*>(lpcs->lpCreateParams);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LPARAM>(data_object));
+
+  data_object->download_progress_window_ = hwnd;
+  data_object->download_progress_control_ =
+      CreateWindowEx(0, PROGRESS_CLASS, (LPTSTR)NULL, WS_CHILD | WS_VISIBLE, 20,
+                     60, 686, 30, hwnd, (HMENU)0, CURRENT_MODULE(), NULL);
+  if (!data_object->download_progress_control_)
+    PLOG(ERROR) << "Failed to create download progress control";
+  else
+    SendMessage(data_object->download_progress_control_, PBM_SETPOS,
+                (WPARAM)data_object->download_progress_, 0);
+  HWND hwndButton =
+      CreateWindow(WC_BUTTON, L"Cancel",
+                   WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 563,
+                   128, 143, 48, hwnd, NULL, CURRENT_MODULE(), NULL);
+  if (!hwndButton)
+    PLOG(ERROR) << "Failed to create download progress cancel button";
+  else {
+    NONCLIENTMETRICS metrics = {sizeof(metrics)};
+    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, metrics.cbSize, &metrics, 0);
+
+    data_object->download_progress_font_ =
+        CreateFontIndirect(&metrics.lfCaptionFont);
+
+    if (!data_object->download_progress_font_)
+      PLOG(ERROR) << "Failed to create download progress window front";
+    else
+      SendMessage(hwndButton, WM_SETFONT,
+                  (WPARAM)data_object->download_progress_font_,
+                  MAKELPARAM(TRUE, 0));
+  }
+
+  ShowWindow(hwnd, SW_SHOWNOACTIVATE);
+  return TRUE;
+}
+
+void OnDestroy(HWND hwnd) {
+  DataObjectImpl* data_object =
+      reinterpret_cast<DataObjectImpl*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
+  if (data_object->download_progress_font_)
+    DeleteObject(data_object->download_progress_font_);
+
+  PostQuitMessage(0);
+}
+
+void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) {
+  DataObjectImpl* data_object =
+      reinterpret_cast<DataObjectImpl*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
+  if (codeNotify == BN_CLICKED) {
+    data_object->download_file_provider_->Stop();
+    if (!DestroyWindow(hwnd))
+      PLOG(ERROR) << "Failed to destroy download progress window";
+  }
+}
+
+LRESULT CALLBACK WindowProc(HWND hwnd,
+                            UINT uiMsg,
+                            WPARAM wParam,
+                            LPARAM lParam) {
+  switch (uiMsg) {
+    HANDLE_MSG(hwnd, WM_CREATE, OnCreate);
+    HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);
+    HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
+  }
+  return DefWindowProc(hwnd, uiMsg, wParam, lParam);
+}
+
+const wchar_t kDragDownloadingWindowClassName[] = L"Front_DragDownloadWindow";
+
+class DragDownloadWindowClass {
+ public:
+  DragDownloadWindowClass();
+  ~DragDownloadWindowClass();
+
+  ATOM atom() { return atom_; }
+  HINSTANCE instance() { return instance_; }
+
+ private:
+  ATOM atom_;
+  HINSTANCE instance_;
+
+  DISALLOW_COPY_AND_ASSIGN(DragDownloadWindowClass);
+};
+
+static base::LazyInstance<DragDownloadWindowClass>::DestructorAtExit
+    g_window_class = LAZY_INSTANCE_INITIALIZER;
+
+DragDownloadWindowClass::DragDownloadWindowClass()
+    : atom_(0), instance_(CURRENT_MODULE()) {
+  WNDCLASSEX window_class;
+  window_class.cbSize = sizeof(window_class);
+  window_class.style = 0;
+  window_class.lpfnWndProc = &base::win::WrappedWindowProc<WindowProc>;
+  window_class.cbClsExtra = 0;
+  window_class.cbWndExtra = 0;
+  window_class.hInstance = instance_;
+  window_class.hIcon = NULL;
+  window_class.hCursor = NULL;
+  window_class.hbrBackground = NULL;
+  window_class.lpszMenuName = NULL;
+  window_class.lpszClassName = kDragDownloadingWindowClassName;
+  window_class.hIconSm = NULL;
+  atom_ = RegisterClassEx(&window_class);
+  if (atom_ == 0) {
+    PLOG(ERROR) << "Failed to register the window class for the download "
+                   "progress window";
+  }
+}
+
+DragDownloadWindowClass::~DragDownloadWindowClass() {
+  if (atom_ != 0) {
+    BOOL result = UnregisterClass(MAKEINTATOM(atom_), instance_);
+    // Hitting this DCHECK means that some download progress windows objects
+    // were leaked.
+    DCHECK(result);
+  }
 }

-void DataObjectImpl::OnDownloadAborted() {}
+#pragma comment(lib, "Comctl32.lib")
+
+DWORD WINAPI DownloadThread(LPVOID parameter) {
+  LOG(INFO) << "DownloadThread";
+  DataObjectImpl* data_object =
+      reinterpret_cast<DataObjectImpl*>(parameter);
+
+  if (data_object->download_finished_)
+    return 0;
+
+  POINT point{};
+  GetCursorPos(&point);
+
+  DragDownloadWindowClass& window_class = g_window_class.Get();
+
+  if (!CreateWindowEx(WS_EX_TOPMOST, MAKEINTATOM(window_class.atom()),
+                      TEXT("Downloading..."), WS_POPUP | WS_CAPTION, point.x,
+                      point.y, 732, 245, GetDesktopWindow(), NULL,
+                      CURRENT_MODULE(), data_object)) {
+    PLOG(ERROR) << "Failed to create download progress window";
+    return 0;
+  }
+
+  MSG msg;
+  while (GetMessage(&msg, NULL, 0, 0)) {
+    TranslateMessage(&msg);
+    DispatchMessage(&msg);
+  }
+
+  data_object->download_progress_window_ = 0;
+
+  return 0;
+}
+
+HRESULT DataObjectImpl::WaitForDownload() {
+  HANDLE thread = CreateThread(NULL, 0, &DownloadThread, this, 0, NULL);
+  if (!thread)
+    PLOG(ERROR) << "Failed to create download progress thread";
+  else
+    CloseHandle(thread);
+
+  LOG(INFO) << "Waiting for download";
+  if (!download_file_provider_->Wait()) {
+    LOG(INFO) << "Wait failed, DV_E_FORMATETC";
+    if (download_progress_window_)
+      PostMessage(download_progress_window_, WM_CLOSE, 0, 0);
+    is_aborting_ = true;
+    return DV_E_FORMATETC;
+  }
+
+  LOG(INFO) << "Wait finished";
+  if (download_progress_window_)
+    PostMessage(download_progress_window_, WM_CLOSE, 0, 0);
+
+  download_finished_ = true;
+  return S_OK;
+}

 HRESULT DataObjectImpl::GetData(FORMATETC* format_etc, STGMEDIUM* medium) {
+  LOG(INFO) << "GetData in_drag_loop: " << in_drag_loop_
+            << ", format_etc: " << FormatFormatEtc(format_etc)
+            << ", is_aborting_: " << is_aborting_;
   if (is_aborting_)
     return DV_E_FORMATETC;

   for (const std::unique_ptr<StoredDataInfo>& content : contents_) {
     if (content->format_etc.cfFormat == format_etc->cfFormat &&
-        content->format_etc.lindex == format_etc->lindex &&
+        //content->format_etc.lindex == format_etc->lindex &&
         (content->format_etc.tymed & format_etc->tymed)) {
+      if (download_file_provider_ && content->format_etc.cfFormat == CF_HDROP &&
+          !in_drag_loop_ && !download_finished_ && !is_aborting_) {
+        HRESULT result = WaitForDownload();
+        if (FAILED(result))
+          return result;
+
+        return GetData(format_etc, medium);
+      }
+
       // If medium is NULL, delay-rendering will be used.
       if (content->medium) {
         DuplicateMedium(content->format_etc.cfFormat, content->medium, medium);
@@ -952,19 +1273,37 @@ HRESULT DataObjectImpl::GetData(FORMATETC* format_etc, STGMEDIUM* medium) {
     }
   }

+  LOG(INFO) << "GetData no matching format, DV_E_FORMATETC";
   return DV_E_FORMATETC;
 }

 HRESULT DataObjectImpl::GetDataHere(FORMATETC* format_etc,
                                     STGMEDIUM* medium) {
+  LOG(INFO) << "GetDataHere";
   return DATA_E_FORMATETC;
 }

 HRESULT DataObjectImpl::QueryGetData(FORMATETC* format_etc) {
+  LOG(INFO) << "QueryGetData in_drag_loop: " << in_drag_loop_
+            << " format_etc: " << FormatFormatEtc(format_etc);
+  if (format_etc->cfFormat == ClipboardFormatType::GetType("CF_FrontDragSource").ToFormatEtc().cfFormat)
+    return S_OK;
+
+  if (format_etc->cfFormat == ClipboardFormatType::GetType("CF_FrontInDragLoop").ToFormatEtc().cfFormat)
+    return in_drag_loop_ ? S_OK : DV_E_FORMATETC;
+
+  if (download_file_provider_ && format_etc->cfFormat == CF_HDROP &&
+      !in_drag_loop_ && !download_finished_ && !is_aborting_) {
+    HRESULT result = WaitForDownload();
+    if (FAILED(result))
+      return result;
+  }
+
   for (const std::unique_ptr<StoredDataInfo>& content : contents_) {
     if (content->format_etc.cfFormat == format_etc->cfFormat)
       return S_OK;
   }
+  LOG(INFO) << "QueryGetData DV_E_FORMATETC";
   return DV_E_FORMATETC;
 }

@@ -976,6 +1315,8 @@ HRESULT DataObjectImpl::GetCanonicalFormatEtc(

 HRESULT DataObjectImpl::SetData(
     FORMATETC* format_etc, STGMEDIUM* medium, BOOL should_release) {
+  LOG(INFO) << "SetData in_drag_loop: " << in_drag_loop_
+            << " format_etc: " << FormatFormatEtc(format_etc);
   RemoveData(*format_etc);

   STGMEDIUM* local_medium = new STGMEDIUM;
@@ -1027,26 +1368,31 @@ HRESULT DataObjectImpl::EnumDAdvise(IEnumSTATDATA** enumerator) {

 HRESULT DataObjectImpl::EndOperation(
     HRESULT result, IBindCtx* reserved, DWORD effects) {
+  LOG(INFO) << "EndOperation";
   async_operation_started_ = false;
   return S_OK;
 }

 HRESULT DataObjectImpl::GetAsyncMode(BOOL* is_op_async) {
+  LOG(INFO) << "GetAsyncMode";
   *is_op_async = in_async_mode_ ? VARIANT_TRUE : VARIANT_FALSE;
   return S_OK;
 }

 HRESULT DataObjectImpl::InOperation(BOOL* in_async_op) {
+  LOG(INFO) << "InOperation";
   *in_async_op = async_operation_started_ ? VARIANT_TRUE : VARIANT_FALSE;
   return S_OK;
 }

 HRESULT DataObjectImpl::SetAsyncMode(BOOL do_op_async) {
+  LOG(INFO) << "SetAsyncMode";
   in_async_mode_ = !!do_op_async;
   return S_OK;
 }

 HRESULT DataObjectImpl::StartOperation(IBindCtx* reserved) {
+  LOG(INFO) << "StartOperation";
   async_operation_started_ = true;
   return S_OK;
 }
@@ -1058,11 +1404,17 @@ HRESULT DataObjectImpl::QueryInterface(const IID& iid, void** object) {
   if (!object)
     return E_POINTER;
   if (IsEqualIID(iid, IID_IDataObject) || IsEqualIID(iid, IID_IUnknown)) {
+    LOG(INFO) << "QueryInterface IID_IDataObject";
     *object = static_cast<IDataObject*>(this);
   } else if (in_async_mode_ &&
              IsEqualIID(iid, __uuidof(IDataObjectAsyncCapability))) {
+    LOG(INFO) << "QueryInterface IDataObjectAsyncCapability";
     *object = static_cast<IDataObjectAsyncCapability*>(this);
   } else {
+    OLECHAR* guidString;
+    StringFromCLSID(iid, &guidString);
+    LOG(INFO) << "QueryInterface " << guidString;
+    ::CoTaskMemFree(guidString);
     *object = NULL;
     return E_NOINTERFACE;
   }
diff --git a/ui/base/dragdrop/os_exchange_data_provider_win.h b/ui/base/dragdrop/os_exchange_data_provider_win.h
index 70fba4d76117cf31e1841ec324d6fb1d347b0265..416b8707601c17fc3346b9b445b1cebe157c0d33 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_win.h
+++ b/ui/base/dragdrop/os_exchange_data_provider_win.h
@@ -45,6 +45,7 @@ class DataObjectImpl : public DownloadFileObserver,

   // DownloadFileObserver implementation:
   void OnDownloadCompleted(const base::FilePath& file_path) override;
+  void OnDownloadProgressed(int percent_complete) override;
   void OnDownloadAborted() override;

   // IDataObject implementation:
@@ -112,6 +113,19 @@ class DataObjectImpl : public DownloadFileObserver,
   bool in_drag_loop_;
   bool in_async_mode_;
   bool async_operation_started_;
+
+  bool download_finished_;
+  HWND download_progress_window_;
+  HWND download_progress_control_;
+  HFONT download_progress_font_;
+  DownloadFileProvider* download_file_provider_;
+  int download_progress_;
+
+  HRESULT WaitForDownload();
+  friend DWORD WINAPI DownloadThread(LPVOID parameter);
+  friend BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpcs);
+  friend void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
+  friend void OnDestroy(HWND hwnd);
 };

 class UI_BASE_EXPORT OSExchangeDataProviderWin
diff --git a/ui/views/widget/desktop_aura/desktop_drag_drop_client_win.cc b/ui/views/widget/desktop_aura/desktop_drag_drop_client_win.cc
index 984d4098effff811e636f57f1d344f253e717d3a..5614045879d32ed84add141f4ee47eb992d64f04 100644
--- a/ui/views/widget/desktop_aura/desktop_drag_drop_client_win.cc
+++ b/ui/views/widget/desktop_aura/desktop_drag_drop_client_win.cc
@@ -4,6 +4,7 @@

 #include "ui/views/widget/desktop_aura/desktop_drag_drop_client_win.h"

+#include "base/logging.h"
 #include "base/metrics/histogram_macros.h"
 #include "ui/base/dragdrop/drag_drop_types.h"
 #include "ui/base/dragdrop/drag_source_win.h"
@@ -49,10 +50,12 @@ int DesktopDragDropClientWin::StartDragAndDrop(
   UMA_HISTOGRAM_ENUMERATION("Event.DragDrop.Start", source,
                             ui::DragDropTypes::DRAG_EVENT_SOURCE_COUNT);

+  LOG(INFO) << "StartDragAndDrop operation: " << operation;
   HRESULT result = DoDragDrop(
       ui::OSExchangeDataProviderWin::GetIDataObject(*data.get()),
       drag_source_.Get(),
       ui::DragDropTypes::DragOperationToDropEffect(operation), &effect);
+  LOG(INFO) << "StartDragAndDrop result: " << result << ", effect: " << effect;
   drag_source_copy->set_data(nullptr);

   if (alive)
